"use strict";
/**
 * Copyright 2018, OpenCensus Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const noop_logger_1 = require("../../common/noop-logger");
const clock_1 = require("../../internal/clock");
const util_1 = require("../../internal/util");
const types = require("./types");
const STATUS_OK = {
    code: types.CanonicalCode.OK
};
/** Defines a base model for spans. */
class SpanBase {
    /** Constructs a new SpanBaseModel instance. */
    constructor() {
        /** Indicates if this span was started */
        this.startedLocal = false;
        /** Indicates if this span was ended */
        this.endedLocal = false;
        /** Indicates if this span was forced to end */
        // @ts-ignore
        this.truncated = false;
        /** An object to log information to */
        this.logger = noop_logger_1.noopLogger;
        /** A set of attributes, each in the format [KEY]:[VALUE] */
        this.attributes = {};
        /** A text annotation with a set of attributes. */
        this.annotations = [];
        /** An event describing a message sent/received between Spans */
        this.messageEvents = [];
        /** Pointers from the current span to another span */
        this.links = [];
        /** If the parent span is in another process. */
        this.remoteParent = false;
        /** The span ID of this span's parent. If it's a root span, must be empty */
        this.parentSpanId = '';
        /** The resource name of the span */
        this.name = 'span';
        /** Kind of span. */
        this.kind = types.SpanKind.UNSPECIFIED;
        /** A final status for this span */
        this.status = STATUS_OK;
        /** Trace Parameters */
        this.activeTraceParams = {};
        /** The number of dropped attributes. */
        this.droppedAttributesCount = 0;
        /** The number of dropped links. */
        this.droppedLinksCount = 0;
        /** The number of dropped annotations. */
        this.droppedAnnotationsCount = 0;
        /** The number of dropped message events. */
        this.droppedMessageEventsCount = 0;
        this.className = this.constructor.name;
        this.id = util_1.randomSpanId();
    }
    /** Indicates if span was started. */
    get started() {
        return this.startedLocal;
    }
    /** Indicates if span was ended. */
    get ended() {
        return this.endedLocal;
    }
    /**
     * Gives a timestamp that indicates the span's start time in RFC3339 UTC
     * "Zulu" format.
     */
    get startTime() {
        if (!this.clock) {
            this.logger.debug('calling startTime() on null clock');
            return new Date();
        }
        return this.clock.startTime;
    }
    /**
     * Gives a timestap that indicates the span's end time in RFC3339 UTC
     * "Zulu" format.
     */
    get endTime() {
        if (!this.clock) {
            this.logger.debug('calling endTime() on null clock');
            return new Date();
        }
        return this.clock.endTime;
    }
    /**
     * Gives a timestap that indicates the span's duration in RFC3339 UTC
     * "Zulu" format.
     */
    get duration() {
        if (!this.clock) {
            this.logger.debug('calling duration() on null clock');
            return 0;
        }
        return this.clock.duration;
    }
    /** Gives the TraceContext of the span. */
    get spanContext() {
        return {
            traceId: this.traceId,
            spanId: this.id,
            options: 0x1,
            traceState: this.traceState
        };
    }
    /**
     * Adds an atribute to the span.
     * @param key Describes the value added.
     * @param value The result of an operation.
     */
    addAttribute(key, value) {
        if (this.attributes[key]) {
            delete this.attributes[key];
        }
        if (Object.keys(this.attributes).length >=
            this.activeTraceParams.numberOfAttributesPerSpan) {
            this.droppedAttributesCount++;
            const attributeKeyToDelete = Object.keys(this.attributes).shift();
            if (attributeKeyToDelete) {
                delete this.attributes[attributeKeyToDelete];
            }
        }
        this.attributes[key] = value;
    }
    /**
     * Adds an annotation to the span.
     * @param description Describes the event.
     * @param attributes A set of attributes on the annotation.
     * @param timestamp A time, in milliseconds. Defaults to Date.now()
     */
    addAnnotation(description, attributes, timestamp = 0) {
        if (this.annotations.length >=
            this.activeTraceParams.numberOfAnnontationEventsPerSpan) {
            this.annotations.shift();
            this.droppedAnnotationsCount++;
        }
        this.annotations.push({
            'description': description,
            'attributes': attributes || {},
            'timestamp': timestamp ? timestamp : Date.now(),
        });
    }
    /**
     * Adds a link to the span.
     * @param traceId The trace ID for a trace within a project.
     * @param spanId The span ID for a span within a trace.
     * @param type The relationship of the current span relative to the linked.
     * @param attributes A set of attributes on the link.
     */
    addLink(traceId, spanId, type, attributes) {
        if (this.links.length >= this.activeTraceParams.numberOfLinksPerSpan) {
            this.links.shift();
            this.droppedLinksCount++;
        }
        this.links.push({
            'traceId': traceId,
            'spanId': spanId,
            'type': type,
            'attributes': attributes || {}
        });
    }
    /**
     * Adds a message event to the span.
     * @param type The type of message event.
     * @param id An identifier for the message event.
     * @param timestamp A time in milliseconds. Defaults to Date.now()
     * @param uncompressedSize The number of uncompressed bytes sent or received
     * @param compressedSize The number of compressed bytes sent or received. If
     *     zero or undefined, assumed to be the same size as uncompressed.
     */
    addMessageEvent(type, id, timestamp = 0, uncompressedSize, compressedSize) {
        if (this.messageEvents.length >=
            this.activeTraceParams.numberOfMessageEventsPerSpan) {
            this.messageEvents.shift();
            this.droppedMessageEventsCount++;
        }
        this.messageEvents.push({
            type,
            id,
            timestamp: timestamp ? timestamp : Date.now(),
            uncompressedSize,
            compressedSize,
        });
    }
    /**
     * Sets a status to the span.
     * @param code The canonical status code.
     * @param message optional A developer-facing error message.
     */
    setStatus(code, message) {
        this.status = { code, message };
    }
    /** Starts the span. */
    start() {
        if (this.started) {
            this.logger.debug('calling %s.start() on already started %s %o', this.className, this.className, { id: this.id, name: this.name, type: this.kind });
            return;
        }
        this.clock = new clock_1.Clock();
        this.startedLocal = true;
    }
    /** Ends the span. */
    end() {
        if (this.ended) {
            this.logger.debug('calling %s.end() on already ended %s %o', this.className, this.className, { id: this.id, name: this.name, type: this.kind });
            return;
        }
        if (!this.started) {
            this.logger.error('calling %s.end() on un-started %s %o', this.className, this.className, { id: this.id, name: this.name, type: this.kind });
            return;
        }
        this.startedLocal = false;
        this.endedLocal = true;
        this.clock.end();
    }
    /** Forces the span to end. */
    truncate() {
        this.truncated = true;
        this.end();
        this.logger.debug('truncating %s  %o', this.className, { id: this.id, name: this.name });
    }
}
exports.SpanBase = SpanBase;
//# sourceMappingURL=span-base.js.map