"use strict";
/**
 * Copyright 2018, OpenCensus Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid");
const logger = require("../../common/console-logger");
const cls = require("../../internal/cls");
const noop_propagation_1 = require("../propagation/noop-propagation");
const sampler_1 = require("../sampler/sampler");
const no_record_root_span_1 = require("./no-record/no-record-root-span");
const no_record_span_1 = require("./no-record/no-record-span");
const root_span_1 = require("./root-span");
const types = require("./types");
/**
 * This class represent a tracer.
 */
class CoreTracer {
    /** Constructs a new TraceImpl instance. */
    constructor() {
        /** A list of end span event listeners */
        this.eventListenersLocal = [];
        /** Bit to represent whether trace is sampled or not. */
        this.IS_SAMPLED = 0x1;
        /** A configuration for starting the tracer */
        this.logger = logger.logger();
        this.activeLocal = false;
        this.contextManager = cls.getNamespace();
        this.clearCurrentTrace();
        this.activeTraceParams = {};
    }
    /** Gets the current root span. */
    get currentRootSpan() {
        return this.contextManager.get('rootspan');
    }
    /** Sets the current root span. */
    set currentRootSpan(root) {
        if (this.contextManager.active) {
            this.contextManager.set('rootspan', root);
        }
    }
    /** A propagation instance */
    get propagation() {
        if (this.config && this.config.propagation) {
            return this.config.propagation;
        }
        return noop_propagation_1.noopPropagation;
    }
    /**
     * Starts a tracer.
     * @param config A tracer configuration object to start a tracer.
     */
    start(config) {
        this.activeLocal = true;
        this.config = config;
        this.logger = this.config.logger || logger.logger();
        this.sampler =
            sampler_1.SamplerBuilder.getSampler(config.samplingRate || sampler_1.DEFAULT_SAMPLING_RATE);
        if (config.traceParams) {
            this.activeTraceParams.numberOfAnnontationEventsPerSpan =
                sampler_1.TraceParamsBuilder.getNumberOfAnnotationEventsPerSpan(config.traceParams);
            this.activeTraceParams.numberOfAttributesPerSpan =
                sampler_1.TraceParamsBuilder.getNumberOfAttributesPerSpan(config.traceParams);
            this.activeTraceParams.numberOfMessageEventsPerSpan =
                sampler_1.TraceParamsBuilder.getNumberOfMessageEventsPerSpan(config.traceParams);
            this.activeTraceParams.numberOfLinksPerSpan =
                sampler_1.TraceParamsBuilder.getNumberOfLinksPerSpan(config.traceParams);
        }
        return this;
    }
    /** Stops the tracer. */
    stop() {
        this.activeLocal = false;
        return this;
    }
    /** Gets the list of event listeners. */
    get eventListeners() {
        return this.eventListenersLocal;
    }
    /** Indicates if the tracer is active or not. */
    get active() {
        return this.activeLocal;
    }
    /**
     * Starts a root span.
     * @param options A TraceOptions object to start a root span.
     * @param fn A callback function to run after starting a root span.
     */
    startRootSpan(options, fn) {
        return this.contextManager.runAndReturn((root) => {
            let traceId;
            if (options && options.spanContext && options.spanContext.traceId) {
                traceId = options.spanContext.traceId;
            }
            else {
                // New root span.
                traceId = uuid.v4().split('-').join('');
            }
            const name = options && options.name ? options.name : 'span';
            const kind = options && options.kind ? options.kind : types.SpanKind.UNSPECIFIED;
            let parentSpanId = '';
            let traceState;
            if (options && options.spanContext) {
                // New child span.
                parentSpanId = options.spanContext.spanId || '';
                traceState = options.spanContext.traceState;
            }
            if (this.active) {
                const sampleDecision = this.makeSamplingDecision(options, traceId);
                if (sampleDecision) {
                    const rootSpan = new root_span_1.RootSpan(this, name, kind, traceId, parentSpanId, traceState);
                    this.currentRootSpan = rootSpan;
                    rootSpan.start();
                    return fn(rootSpan);
                }
            }
            else {
                this.logger.debug('Tracer is inactive, can\'t start new RootSpan');
            }
            const noRecordRootSpan = new no_record_root_span_1.NoRecordRootSpan(this, name, kind, traceId, parentSpanId, traceState);
            this.currentRootSpan = noRecordRootSpan;
            return fn(noRecordRootSpan);
        });
    }
    /** Notifies listeners of the span start. */
    onStartSpan(root) {
        if (!this.active)
            return;
        if (!root) {
            return this.logger.debug('cannot start trace - no active trace found');
        }
        if (this.currentRootSpan !== root) {
            this.logger.debug('currentRootSpan != root on notifyStart. Need more investigation.');
        }
        this.notifyStartSpan(root);
    }
    /** Notifies listeners of the span end. */
    onEndSpan(root) {
        if (!this.active)
            return;
        if (!root) {
            this.logger.debug('cannot end trace - no active trace found');
            return;
        }
        if (this.currentRootSpan !== root) {
            this.logger.debug('currentRootSpan != root on notifyEnd. Need more investigation.');
        }
        this.notifyEndSpan(root);
    }
    /**
     * Registers an end span event listener.
     * @param listener The listener to register.
     */
    registerSpanEventListener(listener) {
        this.eventListenersLocal.push(listener);
    }
    /**
     * Unregisters an end span event listener.
     * @param listener The listener to unregister.
     */
    unregisterSpanEventListener(listener) {
        const index = this.eventListenersLocal.indexOf(listener, 0);
        if (index > -1) {
            this.eventListeners.splice(index, 1);
        }
    }
    notifyStartSpan(root) {
        this.logger.debug('starting to notify listeners the start of rootspans');
        if (this.eventListenersLocal && this.eventListenersLocal.length > 0) {
            for (const listener of this.eventListenersLocal) {
                listener.onStartSpan(root);
            }
        }
    }
    notifyEndSpan(root) {
        this.logger.debug('starting to notify listeners the end of rootspans');
        if (this.eventListenersLocal && this.eventListenersLocal.length > 0) {
            for (const listener of this.eventListenersLocal) {
                listener.onEndSpan(root);
            }
        }
    }
    /** Clears the current root span. */
    clearCurrentTrace() {
        // TODO: Remove null reference and ts-ignore check.
        //@ts-ignore
        this.currentRootSpan = null;
    }
    /**
     * Starts a span.
     * @param nameOrOptions Span name string or SpanOptions object.
     * @param kind Span kind if not using SpanOptions object.
     */
    startChildSpan(nameOrOptions, kind) {
        if (!this.currentRootSpan) {
            this.logger.debug('no current trace found - must start a new root span first');
            return new no_record_span_1.NoRecordSpan();
        }
        return this.currentRootSpan.startChildSpan(nameOrOptions, kind);
    }
    /**
     * Binds the trace context to the given function.
     * This is necessary in order to create child spans correctly in functions
     * that are called asynchronously (for example, in a network response
     * handler).
     * @param fn A function to which to bind the trace context.
     */
    wrap(fn) {
        if (!this.active) {
            return fn;
        }
        const namespace = this.contextManager;
        return namespace.bind(fn);
    }
    /**
     * Binds the trace context to the given event emitter.
     * This is necessary in order to create child spans correctly in event
     * handlers.
     * @param emitter An event emitter whose handlers should have
     *     the trace context binded to them.
     */
    wrapEmitter(emitter) {
        if (!this.active) {
            return;
        }
        const namespace = this.contextManager;
        namespace.bindEmitter(emitter);
    }
    /** Determine whether to sample request or not. */
    makeSamplingDecision(options, traceId) {
        // If users set a specific sampler in the TraceOptions, use it.
        if (options && options.samplingRate !== undefined &&
            options.samplingRate !== null) {
            return sampler_1.SamplerBuilder.getSampler(options.samplingRate)
                .shouldSample(traceId);
        }
        let propagatedSample = null;
        // if there is a context propagation, keep the decision
        if (options && options.spanContext && options.spanContext.options) {
            propagatedSample =
                ((options.spanContext.options & this.IS_SAMPLED) !== 0);
        }
        let sampleDecision = !!propagatedSample;
        if (!sampleDecision) {
            // Use the default global sampler
            sampleDecision = this.sampler.shouldSample(traceId);
        }
        return sampleDecision;
    }
}
exports.CoreTracer = CoreTracer;
//# sourceMappingURL=tracer.js.map